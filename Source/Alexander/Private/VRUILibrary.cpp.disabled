// Copyright Epic Games, Inc. All Rights Reserved.

#include "VRUILibrary.h"
#include "Components/WidgetComponent.h"
#include "GameFramework/Pawn.h"
#include "Camera/CameraComponent.h"
#include "Kismet/KismetMathLibrary.h"
#include "TimerManager.h"
#include "Engine/World.h"

UWidgetComponent* UVRUILibrary::CreateVRWidget(
	AActor* Owner,
	TSubclassOf<UUserWidget> WidgetClass,
	FTransform RelativeTransform,
	FVector2D Size)
{
	if (!Owner || !WidgetClass)
	{
		UE_LOG(LogTemp, Error, TEXT("CreateVRWidget: Invalid parameters"));
		return nullptr;
	}

	// Create widget component
	UWidgetComponent* WidgetComp = NewObject<UWidgetComponent>(Owner);
	if (!WidgetComp)
	{
		return nullptr;
	}

	// Configure for VR
	WidgetComp->SetWidgetClass(WidgetClass);
	WidgetComp->SetDrawSize(Size);
	WidgetComp->SetWidgetSpace(EWidgetSpace::World);
	WidgetComp->SetGeometryMode(EWidgetGeometryMode::Plane);
	
	// VR-specific settings
	WidgetComp->SetTwoSided(false);
	WidgetComp->SetBackgroundColor(FLinearColor::Transparent);
	WidgetComp->SetBlendMode(EWidgetBlendMode::Transparent);
	
	// Attach to owner
	WidgetComp->SetupAttachment(Owner->GetRootComponent());
	WidgetComp->SetRelativeTransform(RelativeTransform);
	WidgetComp->RegisterComponent();

	// Enable interaction by default
	EnableVRInteraction(WidgetComp, true);

	UE_LOG(LogTemp, Log, TEXT("Created VR widget for %s"), *Owner->GetName());
	return WidgetComp;
}

UWidgetComponent* UVRUILibrary::CreateVRWidgetWithConfig(
	AActor* Owner,
	TSubclassOf<UUserWidget> WidgetClass,
	const FVRWidgetConfig& Config,
	FTransform RelativeTransform)
{
	UWidgetComponent* Widget = CreateVRWidget(Owner, WidgetClass, RelativeTransform, Config.Size);
	
	if (Widget)
	{
		ApplyVRWidgetSettings(Widget, Config);
	}

	return Widget;
}

void UVRUILibrary::UpdateVRWidgetScale(
	UWidgetComponent* Widget,
	APawn* Viewer,
	float MinScale,
	float MaxScale)
{
	if (!Widget || !Viewer)
	{
		return;
	}

	// Get viewer camera
	UCameraComponent* Camera = Viewer->FindComponentByClass<UCameraComponent>();
	if (!Camera)
	{
		return;
	}

	// Calculate distance from camera to widget
	float Distance = FVector::Dist(Camera->GetComponentLocation(), Widget->GetComponentLocation());

	// Calculate scale based on distance
	float OptimalDistance = 150.0f; // 150cm default
	float Scale = CalculateDistanceBasedScale(Distance, MinScale, MaxScale, OptimalDistance);

	// Apply scale
	FVector CurrentScale = Widget->GetRelativeScale3D();
	Widget->SetRelativeScale3D(FVector(Scale, CurrentScale.Y, CurrentScale.Z));
}

void UVRUILibrary::EnableVRInteraction(
	UWidgetComponent* Widget,
	bool bEnablePointerEvents)
{
	if (!Widget)
	{
		return;
	}

	Widget->SetCollisionEnabled(ECollisionEnabled::QueryOnly);
	Widget->SetCollisionResponseToAllChannels(ECR_Ignore);
	Widget->SetCollisionResponseToChannel(ECC_Visibility, ECR_Block);
	
	if (bEnablePointerEvents)
	{
		Widget->SetGenerateOverlapEvents(true);
	}

	UE_LOG(LogTemp, Log, TEXT("Enabled VR interaction for widget"));
}

UWidgetComponent* UVRUILibrary::CreateVRPanel(
	AActor* Owner,
	EVRUIPanelType PanelType,
	TSubclassOf<UUserWidget> WidgetClass,
	FTransform RelativeTransform)
{
	FVRWidgetConfig Config = GetDefaultVRConfig(PanelType);
	return CreateVRWidgetWithConfig(Owner, WidgetClass, Config, RelativeTransform);
}

void UVRUILibrary::MakeWidgetFaceViewer(
	UWidgetComponent* Widget,
	APawn* Viewer,
	bool bLockYaw)
{
	if (!Widget || !Viewer)
	{
		return;
	}

	// Get viewer camera
	UCameraComponent* Camera = Viewer->FindComponentByClass<UCameraComponent>();
	if (!Camera)
	{
		return;
	}

	// Calculate rotation to face viewer
	FVector DirectionToViewer = Camera->GetComponentLocation() - Widget->GetComponentLocation();
	FRotator LookAtRotation = DirectionToViewer.Rotation();

	if (bLockYaw)
	{
		// Keep pitch and roll, only rotate yaw
		FRotator CurrentRotation = Widget->GetComponentRotation();
		LookAtRotation.Pitch = CurrentRotation.Pitch;
		LookAtRotation.Roll = CurrentRotation.Roll;
	}

	Widget->SetWorldRotation(LookAtRotation);
}

void UVRUILibrary::SetVRComfortFeatures(
	UWidgetComponent* Widget,
	bool bEnableFeatures)
{
	if (!Widget)
	{
		return;
	}

	if (bEnableFeatures)
	{
		// Reduce aggressive animations
		Widget->SetTickMode(ETickMode::Enabled);
		
		// Enable smooth transitions
		// Note: Actual implementation would need timeline components
		
		UE_LOG(LogTemp, Log, TEXT("Enabled VR comfort features"));
	}
}

UWidgetComponent* UVRUILibrary::CreateHolographicWidget(
	AActor* Owner,
	TSubclassOf<UUserWidget> WidgetClass,
	FTransform RelativeTransform,
	FLinearColor HoloColor)
{
	UWidgetComponent* Widget = CreateVRWidget(Owner, WidgetClass, RelativeTransform);
	
	if (Widget)
	{
		// Set holographic appearance
		Widget->SetTintColorAndOpacity(HoloColor);
		Widget->SetBlendMode(EWidgetBlendMode::Transparent);
		
		// Make it emissive-looking
		// Note: Would typically use a holographic material here
		
		UE_LOG(LogTemp, Log, TEXT("Created holographic widget"));
	}

	return Widget;
}

void UVRUILibrary::AttachWidgetToController(
	UWidgetComponent* Widget,
	USceneComponent* ControllerComponent,
	FVector Offset)
{
	if (!Widget || !ControllerComponent)
	{
		UE_LOG(LogTemp, Error, TEXT("AttachWidgetToController: Invalid parameters"));
		return;
	}

	Widget->AttachToComponent(
		ControllerComponent,
		FAttachmentTransformRules::KeepRelativeTransform
	);

	Widget->SetRelativeLocation(Offset);
	
	UE_LOG(LogTemp, Log, TEXT("Attached widget to controller"));
}

FVRWidgetConfig UVRUILibrary::GetDefaultVRConfig(EVRUIPanelType PanelType)
{
	FVRWidgetConfig Config;

	switch (PanelType)
	{
	case EVRUIPanelType::Cockpit:
		Config.Size = FVector2D(1920.0f, 1080.0f);
		Config.MinScale = 1.0f;
		Config.MaxScale = 1.0f;
		Config.OptimalViewDistance = 80.0f;
		Config.bFaceViewer = false;
		Config.bEnableDistanceScaling = false;
		Config.InteractionMethod = EVRUIInteractionMethod::Pointer;
		break;

	case EVRUIPanelType::Menu:
		Config.Size = FVector2D(1200.0f, 900.0f);
		Config.MinScale = 0.8f;
		Config.MaxScale = 2.0f;
		Config.OptimalViewDistance = 150.0f;
		Config.bFaceViewer = true;
		Config.bEnableDistanceScaling = true;
		Config.InteractionMethod = EVRUIInteractionMethod::Pointer;
		break;

	case EVRUIPanelType::Holographic:
		Config.Size = FVector2D(800.0f, 600.0f);
		Config.MinScale = 0.5f;
		Config.MaxScale = 3.0f;
		Config.OptimalViewDistance = 200.0f;
		Config.bFaceViewer = true;
		Config.bEnableDistanceScaling = true;
		Config.InteractionMethod = EVRUIInteractionMethod::Gaze;
		break;

	case EVRUIPanelType::WorldSpace:
		Config.Size = FVector2D(1000.0f, 750.0f);
		Config.MinScale = 1.0f;
		Config.MaxScale = 5.0f;
		Config.OptimalViewDistance = 300.0f;
		Config.bFaceViewer = false;
		Config.bEnableDistanceScaling = true;
		Config.InteractionMethod = EVRUIInteractionMethod::Pointer;
		break;

	case EVRUIPanelType::Attached:
		Config.Size = FVector2D(600.0f, 400.0f);
		Config.MinScale = 0.5f;
		Config.MaxScale = 1.5f;
		Config.OptimalViewDistance = 100.0f;
		Config.bFaceViewer = true;
		Config.bEnableDistanceScaling = false;
		Config.InteractionMethod = EVRUIInteractionMethod::Touch;
		break;

	case EVRUIPanelType::Floating:
		Config.Size = FVector2D(900.0f, 700.0f);
		Config.MinScale = 0.7f;
		Config.MaxScale = 2.5f;
		Config.OptimalViewDistance = 180.0f;
		Config.bFaceViewer = true;
		Config.bEnableDistanceScaling = true;
		Config.InteractionMethod = EVRUIInteractionMethod::Pointer;
		break;

	default:
		// Default safe configuration
		Config.Size = FVector2D(800.0f, 600.0f);
		Config.MinScale = 1.0f;
		Config.MaxScale = 2.0f;
		Config.OptimalViewDistance = 150.0f;
		Config.bFaceViewer = true;
		Config.bEnableDistanceScaling = true;
		Config.InteractionMethod = EVRUIInteractionMethod::Pointer;
		break;
	}

	Config.bEnableComfortFeatures = true;
	return Config;
}

FVector2D UVRUILibrary::CalculateOptimalVRWidgetSize(
	float ViewingDistance,
	float ContentComplexity)
{
	// Base size calculation
	// At 150cm, a comfortable size is around 800x600
	float BaseSize = 800.0f;
	float DistanceFactor = ViewingDistance / 150.0f;
	
	// Adjust for content complexity (more complex = larger)
	float ComplexityFactor = 1.0f + (ContentComplexity * 0.5f);
	
	float CalculatedWidth = BaseSize * DistanceFactor * ComplexityFactor;
	float CalculatedHeight = CalculatedWidth * 0.75f; // 4:3 aspect ratio
	
	// Clamp to reasonable values
	CalculatedWidth = FMath::Clamp(CalculatedWidth, 400.0f, 2400.0f);
	CalculatedHeight = FMath::Clamp(CalculatedHeight, 300.0f, 1800.0f);

	return FVector2D(CalculatedWidth, CalculatedHeight);
}

bool UVRUILibrary::IsWidgetInComfortablePosition(
	UWidgetComponent* Widget,
	APawn* Viewer,
	FText& OutReason)
{
	if (!Widget || !Viewer)
	{
		OutReason = FText::FromString(TEXT("Invalid parameters"));
		return false;
	}

	UCameraComponent* Camera = Viewer->FindComponentByClass<UCameraComponent>();
	if (!Camera)
	{
		OutReason = FText::FromString(TEXT("No camera found"));
		return false;
	}

	FVector CameraLocation = Camera->GetComponentLocation();
	FVector WidgetLocation = Widget->GetComponentLocation();
	FVector CameraForward = Camera->GetForwardVector();

	// Check distance
	float Distance = FVector::Dist(CameraLocation, WidgetLocation);
	if (Distance < 50.0f)
	{
		OutReason = FText::FromString(TEXT("Too close - may cause eye strain"));
		return false;
	}
	if (Distance > 500.0f)
	{
		OutReason = FText::FromString(TEXT("Too far - may be hard to read"));
		return false;
	}

	// Check angle relative to forward view
	FVector ToWidget = (WidgetLocation - CameraLocation).GetSafeNormal();
	float DotProduct = FVector::DotProduct(CameraForward, ToWidget);
	float Angle = FMath::RadiansToDegrees(FMath::Acos(DotProduct));

	if (Angle > 60.0f)
	{
		OutReason = FText::FromString(TEXT("Too far from center of view - uncomfortable neck angle"));
		return false;
	}

	// Check vertical position (shouldn't be too high or low)
	float HeightDifference = WidgetLocation.Z - CameraLocation.Z;
	if (FMath::Abs(HeightDifference) > 100.0f)
	{
		OutReason = FText::FromString(TEXT("Vertical position may cause neck strain"));
		return false;
	}

	OutReason = FText::FromString(TEXT("Comfortable"));
	return true;
}

void UVRUILibrary::AnimateVRWidgetEntrance(
	UWidgetComponent* Widget,
	float Duration)
{
	if (!Widget || Duration <= 0.0f)
	{
		return;
	}

	// Store initial state
	FVector InitialScale = Widget->GetRelativeScale3D();
	FLinearColor InitialTint = Widget->GetTintColorAndOpacity();

	// Set to zero scale and transparent
	Widget->SetRelativeScale3D(FVector::ZeroVector);
	Widget->SetTintColorAndOpacity(FLinearColor(InitialTint.R, InitialTint.G, InitialTint.B, 0.0f));

	// Note: Full implementation would use timeline or animation curve
	// For now, we just log the intent
	UE_LOG(LogTemp, Log, TEXT("Animating widget entrance over %.2f seconds"), Duration);

	// Immediately show for now (proper animation would need timeline)
	Widget->SetRelativeScale3D(InitialScale);
	Widget->SetTintColorAndOpacity(InitialTint);
}

UWidgetComponent* UVRUILibrary::CreateCurvedVRWidget(
	AActor* Owner,
	TSubclassOf<UUserWidget> WidgetClass,
	FTransform RelativeTransform,
	float CurvatureRadius)
{
	UWidgetComponent* Widget = CreateVRWidget(Owner, WidgetClass, RelativeTransform);
	
	if (Widget)
	{
		// Set cylindrical geometry mode
		Widget->SetGeometryMode(EWidgetGeometryMode::Cylinder);
		Widget->SetCylinderArcAngle(90.0f); // 90 degree arc
		
		UE_LOG(LogTemp, Log, TEXT("Created curved VR widget with radius %.1f"), CurvatureRadius);
	}

	return Widget;
}

void UVRUILibrary::ApplyVRWidgetSettings(UWidgetComponent* Widget, const FVRWidgetConfig& Config)
{
	if (!Widget)
	{
		return;
	}

	Widget->SetDrawSize(Config.Size);
	
	if (Config.bReceiveHardwareInput)
	{
		Widget->SetReceiveHardwareInput(true);
	}

	if (Config.bEnableComfortFeatures)
	{
		SetVRComfortFeatures(Widget, true);
	}

	// Apply initial scale
	float InitialScale = (Config.MinScale + Config.MaxScale) * 0.5f;
	FVector ScaleVector(InitialScale, InitialScale, InitialScale);
	Widget->SetRelativeScale3D(ScaleVector);
}

FVector2D UVRUILibrary::GetPanelSizeForType(EVRUIPanelType PanelType)
{
	FVRWidgetConfig Config = GetDefaultVRConfig(PanelType);
	return Config.Size;
}

float UVRUILibrary::CalculateDistanceBasedScale(
	float Distance,
	float MinScale,
	float MaxScale,
	float OptimalDistance)
{
	if (OptimalDistance <= 0.0f)
	{
		return 1.0f;
	}

	// Calculate scale factor based on distance from optimal
	float DistanceRatio = Distance / OptimalDistance;
	
	// Use logarithmic scaling for more natural feel
	float Scale = FMath::Lerp(MinScale, MaxScale, FMath::Clamp(DistanceRatio, 0.0f, 1.0f));
	
	return FMath::Clamp(Scale, MinScale, MaxScale);
}
