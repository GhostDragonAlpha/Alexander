// Copyright Epic Games, Inc. All Rights Reserved.

#include "LiveLinkIntegrationManager.h"
#include "LiveLinkClient.h"
#include "LiveLinkMessageBusSource.h"
#include "ILiveLinkClient.h"
#include "LiveLinkTypes.h"
#include "Roles/LiveLinkTransformRole.h"
#include "Roles/LiveLinkAnimationRole.h"
#include "Roles/LiveLinkCameraRole.h"
#include "Testing/TestLevelGameMode.h"
#include "Testing/TestDataStructures.h"
#include "VRSpaceshipPawn.h"
#include "PerformanceProfiler.h"
#include "Kismet/GameplayStatics.h"
#include "Engine/World.h"
#include "TimerManager.h"

ALiveLinkIntegrationManager::ALiveLinkIntegrationManager()
{
	PrimaryActorTick.bCanEverTick = true;
	PrimaryActorTick.bStartWithTickEnabled = true;
}

void ALiveLinkIntegrationManager::BeginPlay()
{
	Super::BeginPlay();

	// Initialize references
	FindReferences();

	// Register with test level game mode if available
	RegisterWithTestLevelGameMode();

	// Auto-connect if configured
	if (bAutoConnectOnBeginPlay)
	{
		ConnectToLiveLinkHub();
	}

	// Start streaming if configured
	if (bStreamTestResults)
	{
		StartStreamingTestData();
	}

	if (bStreamVRTracking)
	{
		StartStreamingVRData();
	}

	if (bStreamPerformanceMetrics)
	{
		StartStreamingPerformanceData();
	}

	if (bEnableRemoteControl)
	{
		EnableRemoteControl(true);
	}

	UE_LOG(LogTemp, Log, TEXT("Live Link Integration Manager initialized"));
}

void ALiveLinkIntegrationManager::Tick(float DeltaTime)
{
	Super::Tick(DeltaTime);

	TimeSinceLastUpdate += DeltaTime;

	if (TimeSinceLastUpdate >= DataUpdateInterval)
	{
		if (bConnected)
		{
			UpdateLiveLinkData();
			ProcessIncomingLiveLinkData();
		}
		TimeSinceLastUpdate = 0.0f;
	}
}

void ALiveLinkIntegrationManager::EndPlay(const EEndPlayReason::Type EndPlayReason)
{
	// Stop all streaming
	StopStreamingTestData();
	StopStreamingVRData();
	StopStreamingPerformanceData();
	EnableRemoteControl(false);

	// Disconnect
	DisconnectFromLiveLinkHub();

	Super::EndPlay(EndPlayReason);
}

void ALiveLinkIntegrationManager::ConnectToLiveLinkHub()
{
	if (bConnected)
	{
		LogConnectionStatus(TEXT("Already connected to Live Link Hub"));
		return;
	}

	InitializeLiveLinkClient();

	if (LiveLinkClient)
	{
		// Create message bus source for network connection
		FLiveLinkMessageBusSource NewSource;
		NewSource.ConnectionSettings.IPAddress = LiveLinkHubAddress;
		NewSource.ConnectionSettings.PortNumber = LiveLinkHubPort;
		NewSource.ConnectionSettings.BufferSettings.bShouldDiscardSamples = false;

		// Add the source
		FGuid SourceGuid = LiveLinkClient->AddSource(NewSource);

		if (SourceGuid.IsValid())
		{
			bConnected = true;
			SetupLiveLinkSubjects();
			LogConnectionStatus(FString::Printf(TEXT("Connected to Live Link Hub at %s:%d"),
				*LiveLinkHubAddress, LiveLinkHubPort));
		}
		else
		{
			LogConnectionStatus(TEXT("Failed to connect to Live Link Hub"));
		}
	}
	else
	{
		LogConnectionStatus(TEXT("Live Link client not available"));
	}
}

void ALiveLinkIntegrationManager::DisconnectFromLiveLinkHub()
{
	if (!bConnected)
	{
		return;
	}

	CleanupLiveLinkClient();
	bConnected = false;
	LogConnectionStatus(TEXT("Disconnected from Live Link Hub"));
}

bool ALiveLinkIntegrationManager::IsConnectedToLiveLinkHub() const
{
	return bConnected && LiveLinkClient != nullptr;
}

void ALiveLinkIntegrationManager::StartStreamingTestData()
{
	if (!bConnected)
	{
		LogDataTransmission(TEXT("Test Data"), false);
		return;
	}

	bStreamingTestData = true;
	LogDataTransmission(TEXT("Test Data"), true);
}

void ALiveLinkIntegrationManager::StopStreamingTestData()
{
	bStreamingTestData = false;
	LogDataTransmission(TEXT("Test Data"), false);
}

void ALiveLinkIntegrationManager::StartStreamingVRData()
{
	if (!bConnected)
	{
		LogDataTransmission(TEXT("VR Data"), false);
		return;
	}

	bStreamingVRData = true;
	LogDataTransmission(TEXT("VR Data"), true);
}

void ALiveLinkIntegrationManager::StopStreamingVRData()
{
	bStreamingVRData = false;
	LogDataTransmission(TEXT("VR Data"), false);
}

void ALiveLinkIntegrationManager::StartStreamingPerformanceData()
{
	if (!bConnected)
	{
		LogDataTransmission(TEXT("Performance Data"), false);
		return;
	}

	bStreamingPerformanceData = true;
	LogDataTransmission(TEXT("Performance Data"), true);
}

void ALiveLinkIntegrationManager::StopStreamingPerformanceData()
{
	bStreamingPerformanceData = false;
	LogDataTransmission(TEXT("Performance Data"), false);
}

void ALiveLinkIntegrationManager::EnableRemoteControl(bool bEnable)
{
	bRemoteControlEnabled = bEnable;

	if (bEnable)
	{
		UE_LOG(LogTemp, Log, TEXT("Remote control enabled - external applications can now control test execution"));
	}
	else
	{
		UE_LOG(LogTemp, Log, TEXT("Remote control disabled"));
	}
}

void ALiveLinkIntegrationManager::ProcessIncomingLiveLinkData()
{
	if (!LiveLinkClient || !bRemoteControlEnabled)
	{
		return;
	}

	// Check for incoming remote control data
	// This would process commands from Live Link Hub to control test execution
	ReceiveRemoteControlData();
}

void ALiveLinkIntegrationManager::RegisterWithTestLevelGameMode()
{
	// Find test level game mode
	AGameModeBase* GameMode = UGameplayStatics::GetGameMode(this);
	TestLevelGameMode = Cast<UTestLevelGameMode>(GameMode);

	if (TestLevelGameMode)
	{
		// Register for test result updates
		TestLevelGameMode->OnAllTestsCompleted.AddDynamic(this, &ALiveLinkIntegrationManager::OnTestResultsUpdated);

		UE_LOG(LogTemp, Log, TEXT("Live Link Manager registered with Test Level Game Mode"));
	}
}

void ALiveLinkIntegrationManager::OnTestResultsUpdated(const FTestResults& Results)
{
	LastTestResults = Results;

	// Immediately send updated test results if streaming
	if (bStreamingTestData && bConnected)
	{
		SendTestResultsData();
	}
}

void ALiveLinkIntegrationManager::SetupLiveLinkSubjects()
{
	if (!LiveLinkClient)
	{
		return;
	}

	// Create subjects for different data types
	FLiveLinkSubjectKey TestSubjectKey(TestResultsSubject, FGuid());
	FLiveLinkSubjectKey VRSubjectKey(VRTrackingSubject, FGuid());
	FLiveLinkSubjectKey PerfSubjectKey(PerformanceSubject, FGuid());
	FLiveLinkSubjectKey RemoteSubjectKey(RemoteControlSubject, FGuid());

	// Set up subject data
	LiveLinkClient->CreateSubject(TestSubjectKey);
	LiveLinkClient->CreateSubject(VRSubjectKey);
	LiveLinkClient->CreateSubject(PerfSubjectKey);
	LiveLinkClient->CreateSubject(RemoteSubjectKey);

	UE_LOG(LogTemp, Log, TEXT("Live Link subjects created"));
}

void ALiveLinkIntegrationManager::UpdateLiveLinkData()
{
	if (!bConnected || !LiveLinkClient)
	{
		return;
	}

	// Send data for each enabled stream
	if (bStreamingTestData)
	{
		SendTestResultsData();
	}

	if (bStreamingVRData)
	{
		SendVRTrackingData();
	}

	if (bStreamingPerformanceData)
	{
		SendPerformanceData();
	}
}

void ALiveLinkIntegrationManager::SendTestResultsData()
{
	if (!LiveLinkClient || !bStreamingTestData)
	{
		return;
	}

	// Get current test results
	FTestResults CurrentResults = GetCurrentTestResults();

	// Create Live Link frame data
	FLiveLinkFrameData FrameData;
	FrameData.WorldTime = GetWorld()->GetTimeSeconds();

	// Convert test results to Live Link transform data
	// Use test pass rate as scale, test count as translation, etc.
	FLiveLinkTransformFrameData TransformData;
	TransformData.Transform.SetLocation(FVector(
		CurrentResults.GetTotalTests(),      // X: total tests
		CurrentResults.GetPassedTests(),     // Y: passed tests
		CurrentResults.GetFailedTests()      // Z: failed tests
	));

	float PassRate = CurrentResults.GetOverallPassRate();
	TransformData.Transform.SetScale3D(FVector(PassRate, PassRate, PassRate));

	// Send the frame
	FLiveLinkSubjectKey SubjectKey(TestResultsSubject, FGuid());
	LiveLinkClient->PushSubjectData(SubjectKey, FrameData);
}

void ALiveLinkIntegrationManager::SendVRTrackingData()
{
	if (!LiveLinkClient || !bStreamingVRData)
	{
		return;
	}

	// Get VR tracking data
	FVector PlayerPos = GetPlayerPosition();
	FRotator PlayerRot = GetPlayerRotation();
	FVector HMDPos = GetHMDPosition();
	FRotator HMDRot = GetHMDRotation();

	// Create Live Link frame data
	FLiveLinkFrameData FrameData;
	FrameData.WorldTime = GetWorld()->GetTimeSeconds();

	// Send player transform
	FLiveLinkTransformFrameData PlayerTransform;
	PlayerTransform.Transform.SetLocation(PlayerPos);
	PlayerTransform.Transform.SetRotation(PlayerRot.Quaternion());

	FLiveLinkSubjectKey PlayerSubjectKey(VRTrackingSubject, FGuid());
	LiveLinkClient->PushSubjectData(PlayerSubjectKey, FrameData);

	// Could also send HMD data as separate subject if needed
}

void ALiveLinkIntegrationManager::SendPerformanceData()
{
	if (!LiveLinkClient || !bStreamingPerformanceData)
	{
		return;
	}

	// Get performance metrics
	FPerformanceMetrics PerfMetrics = GetCurrentPerformanceMetrics();

	// Create Live Link frame data
	FLiveLinkFrameData FrameData;
	FrameData.WorldTime = GetWorld()->GetTimeSeconds();

	// Convert performance data to transform
	FLiveLinkTransformFrameData PerfTransform;
	PerfTransform.Transform.SetLocation(FVector(
		PerfMetrics.AverageFPS,           // X: FPS
		PerfMetrics.MemoryUsageMB,        // Y: Memory
		PerfMetrics.DrawCalls             // Z: Draw calls
	));

	PerfTransform.Transform.SetScale3D(FVector(
		PerfMetrics.AverageFrameTime,     // Scale X: Frame time
		PerfMetrics.GPUTime,              // Scale Y: GPU time
		PerfMetrics.CPUTime               // Scale Z: CPU time
	));

	FLiveLinkSubjectKey SubjectKey(PerformanceSubject, FGuid());
	LiveLinkClient->PushSubjectData(SubjectKey, FrameData);
}

void ALiveLinkIntegrationManager::ReceiveRemoteControlData()
{
	if (!LiveLinkClient || !bRemoteControlEnabled)
	{
		return;
	}

	// Check for incoming remote control commands
	// This would process transform data from Live Link Hub to control test execution

	FLiveLinkSubjectKey SubjectKey(RemoteControlSubject, FGuid());
	FLiveLinkFrameData FrameData;

	if (LiveLinkClient->GetSubjectData(SubjectKey, FrameData))
	{
		// Process remote control commands
		// For example, use transform position to trigger specific tests
		// X: Test station index, Y: Command type, Z: Parameter

		FLiveLinkTransformFrameData* TransformData = FrameData.FrameData.Cast<FLiveLinkTransformFrameData>();
		if (TransformData)
		{
			FVector CommandVector = TransformData->Transform.GetLocation();

			int32 StationIndex = FMath::RoundToInt(CommandVector.X);
			int32 CommandType = FMath::RoundToInt(CommandVector.Y);
			float Parameter = CommandVector.Z;

			// Execute remote command
			ExecuteRemoteCommand(StationIndex, CommandType, Parameter);
		}
	}
}

void ALiveLinkIntegrationManager::ExecuteRemoteCommand(int32 StationIndex, int32 CommandType, float Parameter)
{
	if (!TestLevelGameMode)
	{
		return;
	}

	switch (CommandType)
	{
	case 0: // Run all tests
		TestLevelGameMode->RunAllTests();
		UE_LOG(LogTemp, Log, TEXT("Remote command: Run all tests"));
		break;

	case 1: // Run specific station
		{
			TArray<FTestStationLocation> Stations = TestLevelGameMode->GetAllStations();
			if (Stations.IsValidIndex(StationIndex))
			{
				TestLevelGameMode->RunSingleStation(Stations[StationIndex].StationName);
				UE_LOG(LogTemp, Log, TEXT("Remote command: Run station %s"), *Stations[StationIndex].StationName.ToString());
			}
		}
		break;

	case 2: // Stop tests
		TestLevelGameMode->StopAllTests();
		UE_LOG(LogTemp, Log, TEXT("Remote command: Stop all tests"));
		break;

	case 3: // Teleport to station
		{
			TArray<FTestStationLocation> Stations = TestLevelGameMode->GetAllStations();
			if (Stations.IsValidIndex(StationIndex))
			{
				TestLevelGameMode->TeleportPlayerToStation(Stations[StationIndex].StationName);
				UE_LOG(LogTemp, Log, TEXT("Remote command: Teleport to station %s"), *Stations[StationIndex].StationName.ToString());
			}
		}
		break;

	default:
		UE_LOG(LogTemp, Warning, TEXT("Unknown remote command type: %d"), CommandType);
		break;
	}
}

FVector ALiveLinkIntegrationManager::GetPlayerPosition() const
{
	if (VRSpaceshipPawn)
	{
		return VRSpaceshipPawn->GetActorLocation();
	}

	APlayerController* PC = UGameplayStatics::GetPlayerController(GetWorld(), 0);
	if (PC)
	{
		APawn* Pawn = PC->GetPawn();
		if (Pawn)
		{
			return Pawn->GetActorLocation();
		}
	}

	return FVector::ZeroVector;
}

FRotator ALiveLinkIntegrationManager::GetPlayerRotation() const
{
	if (VRSpaceshipPawn)
	{
		return VRSpaceshipPawn->GetActorRotation();
	}

	APlayerController* PC = UGameplayStatics::GetPlayerController(GetWorld(), 0);
	if (PC)
	{
		APawn* Pawn = PC->GetPawn();
		if (Pawn)
		{
			return Pawn->GetActorRotation();
		}
	}

	return FRotator::ZeroRotator;
}

FVector ALiveLinkIntegrationManager::GetHMDPosition() const
{
	// Get HMD position from VR system
	// This would use HeadMountedDisplayFunctionLibrary
	return FVector::ZeroVector; // Placeholder
}

FRotator ALiveLinkIntegrationManager::GetHMDRotation() const
{
	// Get HMD rotation from VR system
	return FRotator::ZeroRotator; // Placeholder
}

FTestResults ALiveLinkIntegrationManager::GetCurrentTestResults() const
{
	if (TestLevelGameMode)
	{
		return TestLevelGameMode->GetOverallResults();
	}

	return LastTestResults;
}

FPerformanceMetrics ALiveLinkIntegrationManager::GetCurrentPerformanceMetrics() const
{
	// Get performance metrics from profiler
	UPerformanceProfiler* Profiler = nullptr;
	if (TestLevelGameMode)
	{
		Profiler = TestLevelGameMode->GetPerformanceProfiler();
	}

	if (Profiler)
	{
		// Convert profiler data to FPerformanceMetrics
		FPerformanceMetrics Metrics;
		Metrics.AverageFPS = Profiler->GetCurrentFPS();
		Metrics.AverageFrameTime = Profiler->GetAverageFrameTime();
		Metrics.MemoryUsageMB = 0.0f; // Would need memory profiler integration
		Metrics.DrawCalls = 0; // Would need render stats integration

		return Metrics;
	}

	return LastPerformanceMetrics;
}

void ALiveLinkIntegrationManager::FindReferences()
{
	// Find VR spaceship pawn
	TArray<AActor*> VRPawns;
	UGameplayStatics::GetAllActorsOfClass(this, AVRSpaceshipPawn::StaticClass(), VRPawns);
	if (VRPawns.Num() > 0)
	{
		VRSpaceshipPawn = Cast<AVRSpaceshipPawn>(VRPawns[0]);
	}
}

void ALiveLinkIntegrationManager::InitializeLiveLinkClient()
{
	// Get the Live Link client from the subsystem
	if (ILiveLinkClient* Client = ILiveLinkClient::Get())
	{
		LiveLinkClient = Client;
	}
}

void ALiveLinkIntegrationManager::CleanupLiveLinkClient()
{
	// Clean up Live Link subjects
	if (LiveLinkClient)
	{
		LiveLinkClient->RemoveSubject(FLiveLinkSubjectKey(TestResultsSubject, FGuid()));
		LiveLinkClient->RemoveSubject(FLiveLinkSubjectKey(VRTrackingSubject, FGuid()));
		LiveLinkClient->RemoveSubject(FLiveLinkSubjectKey(PerformanceSubject, FGuid()));
		LiveLinkClient->RemoveSubject(FLiveLinkSubjectKey(RemoteControlSubject, FGuid()));
	}

	LiveLinkClient = nullptr;
}

void ALiveLinkIntegrationManager::LogConnectionStatus(const FString& Status)
{
	UE_LOG(LogTemp, Log, TEXT("[LiveLink] %s"), *Status);
}

void ALiveLinkIntegrationManager::LogDataTransmission(const FString& DataType, bool bSuccess)
{
	FString Status = bSuccess ? TEXT("started") : TEXT("failed to start");
	UE_LOG(LogTemp, Log, TEXT("[LiveLink] %s streaming %s"), *DataType, *Status);
}
